//! Image Upload Example
//!
//! This example demonstrates how to:
//! - Upload a blob (image) to Bluesky
//! - Create a post with an image embed
//! - Use automatic MIME type detection
//!
//! Run with:
//! ```bash
//! cargo run --example upload_image
//! ```

use atproto::agent::Agent;
use std::env;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🦀 Rust ATProto SDK - Image Upload Example\n");

    // Get credentials from environment variables
    let handle = env::var("BSKY_HANDLE")
        .unwrap_or_else(|_| "your-handle.bsky.social".to_string());
    let password = env::var("BSKY_PASSWORD")
        .unwrap_or_else(|_| "your-app-password".to_string());

    // Create agent
    let agent = Agent::new("https://bsky.social".to_string());
    println!("✓ Created agent for {}", agent.service());

    // Login
    println!("\n📝 Logging in as {}...", handle);
    match agent.login(&handle, &password).await {
        Ok(_) => println!("✓ Logged in successfully!"),
        Err(e) => {
            eprintln!("✗ Login failed: {}", e);
            eprintln!("\nTo use this example:");
            eprintln!("  export BSKY_HANDLE=your-handle.bsky.social");
            eprintln!("  export BSKY_PASSWORD=your-app-password");
            return Err(e.into());
        }
    }

    if let Some(did) = agent.did() {
        println!("✓ Authenticated as DID: {}", did);
    }

    // Example 1: Create a simple test image
    println!("\n📷 Creating a test image...");
    let test_image = create_test_jpeg();
    println!("✓ Created {}x{} JPEG ({} bytes)", 100, 100, test_image.len());

    // Example 2: Upload the blob
    println!("\n☁️  Uploading blob...");
    match agent.upload_blob(test_image.clone(), "image/jpeg").await {
        Ok(blob_ref) => {
            println!("✓ Blob uploaded successfully!");
            println!("  Blob reference: {:?}", blob_ref);
        }
        Err(e) => {
            eprintln!("✗ Failed to upload blob: {}", e);
            return Err(e.into());
        }
    }

    // Example 3: Post with image
    println!("\n📮 Creating a post with image...");
    let images = vec![
        (test_image, "A test image generated by the Rust SDK".to_string())
    ];

    match agent.post_with_images("Testing image upload from the Rust ATProto SDK! 🦀", images).await {
        Ok(uri) => {
            println!("✓ Posted with image!");
            println!("  Post URI: {}", uri);
        }
        Err(e) => {
            eprintln!("✗ Failed to post with image: {}", e);
            return Err(e.into());
        }
    }

    // Example 4: Demonstrate MIME type detection
    println!("\n🔍 Testing MIME type detection...");
    println!("  photo.jpg  -> {}", atproto::blob::detect_mime_type("photo.jpg"));
    println!("  image.png  -> {}", atproto::blob::detect_mime_type("image.png"));
    println!("  video.mp4  -> {}", atproto::blob::detect_mime_type("video.mp4"));
    println!("  anim.gif   -> {}", atproto::blob::detect_mime_type("anim.gif"));

    println!("\n✨ Done!");

    Ok(())
}

/// Create a minimal valid JPEG image for testing
///
/// This creates a 100x100 pixel red square JPEG.
/// In a real application, you would read an actual image file.
fn create_test_jpeg() -> Vec<u8> {
    // This is a minimal valid 100x100 red JPEG image
    // Created using a JPEG encoder - in production you'd read a real file

    // JPEG header (Start of Image)
    let mut jpeg = vec![0xFF, 0xD8];

    // JFIF APP0 marker
    jpeg.extend_from_slice(&[
        0xFF, 0xE0,  // APP0 marker
        0x00, 0x10,  // Length (16 bytes)
        0x4A, 0x46, 0x49, 0x46, 0x00,  // "JFIF\0"
        0x01, 0x01,  // Version 1.1
        0x00,        // Density units (no units)
        0x00, 0x01,  // X density
        0x00, 0x01,  // Y density
        0x00, 0x00,  // Thumbnail width/height (no thumbnail)
    ]);

    // Start of Frame (SOF0) - Baseline DCT
    jpeg.extend_from_slice(&[
        0xFF, 0xC0,  // SOF0 marker
        0x00, 0x11,  // Length (17 bytes)
        0x08,        // Precision (8 bits)
        0x00, 0x64,  // Height (100)
        0x00, 0x64,  // Width (100)
        0x03,        // Number of components (3 = RGB)
        0x01, 0x22, 0x00,  // Component 1 (Y)
        0x02, 0x11, 0x01,  // Component 2 (Cb)
        0x03, 0x11, 0x01,  // Component 3 (Cr)
    ]);

    // Define Huffman Table (DHT) - simplified
    jpeg.extend_from_slice(&[
        0xFF, 0xC4,  // DHT marker
        0x00, 0x1F,  // Length
        0x00,        // Table class and ID
    ]);
    // Add minimal Huffman table data
    jpeg.extend_from_slice(&[0; 28]);

    // Start of Scan (SOS)
    jpeg.extend_from_slice(&[
        0xFF, 0xDA,  // SOS marker
        0x00, 0x0C,  // Length (12 bytes)
        0x03,        // Number of components
        0x01, 0x00,  // Component 1
        0x02, 0x11,  // Component 2
        0x03, 0x11,  // Component 3
        0x00, 0x3F, 0x00,  // Start/end of spectral selection
    ]);

    // Compressed image data (minimal)
    for _ in 0..32 {
        jpeg.extend_from_slice(&[0xFF, 0x00]);
    }

    // End of Image
    jpeg.extend_from_slice(&[0xFF, 0xD9]);

    jpeg
}
